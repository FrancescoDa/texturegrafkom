<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebGL Cube Texture Huruf B</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>

    <!-- Matrix library -->
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>

    <!-- Skrip utama -->
    <script>
      // Skrip utama Anda dimulai di sini
      const vertexShaderSource = `
attribute vec4 aPosition;
attribute vec2 aTexCoord;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
varying vec2 vTexCoord;
void main() {
    gl_Position = uProjectionMatrix * uModelViewMatrix * aPosition;
    vTexCoord = aTexCoord;
}`;

      const fragmentShaderSource = `
precision mediump float;
varying vec2 vTexCoord;
uniform sampler2D uSampler;
void main() {
    gl_FragColor = texture2D(uSampler, vTexCoord);
}`;

      // Setup WebGL
      const canvas = document.getElementById("glcanvas");
      const gl = canvas.getContext("webgl");

      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(
        fragmentShaderSource,
        gl.FRAGMENT_SHADER
      );

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program failed to link:", gl.getProgramInfoLog(program));
      }

      // Data kubus
      const positions = new Float32Array([
        // Depan
        -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,
        // Belakang
        -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1,
        // Atas
        -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,
        // Bawah
        -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
        // Kanan
        1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1,
        // Kiri
        -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1,
      ]);

      const textureCoordinates = new Float32Array([
        // Depan
        0, 0, 1, 0, 1, 1, 0, 1,
        // Belakang
        0, 0, 1, 0, 1, 1, 0, 1,
        // Atas
        0, 0, 1, 0, 1, 1, 0, 1,
        // Bawah
        0, 0, 1, 0, 1, 1, 0, 1,
        // Kanan
        0, 0, 1, 0, 1, 1, 0, 1,
        // Kiri
        0, 0, 1, 0, 1, 1, 0, 1,
      ]);

      const indices = new Uint16Array([
        0,
        1,
        2,
        0,
        2,
        3, // depan
        4,
        5,
        6,
        4,
        6,
        7, // belakang
        8,
        9,
        10,
        8,
        10,
        11, // atas
        12,
        13,
        14,
        12,
        14,
        15, // bawah
        16,
        17,
        18,
        16,
        18,
        19, // kanan
        20,
        21,
        22,
        20,
        22,
        23, // kiri
      ]);

      // Buffer
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      const textureCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      // Attrib
      gl.useProgram(program);

      const aPosition = gl.getAttribLocation(program, "aPosition");
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aPosition);

      const aTexCoord = gl.getAttribLocation(program, "aTexCoord");
      gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
      gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aTexCoord);

      // Load texture
      const texture = gl.createTexture();
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.src = "hurufB.jpg"; // HARUS berada 1 folder dengan file html ini
      image.onload = function () {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          image
        );

        // Setting agar bisa non-power-of-two
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        drawScene();
      };

      function drawScene() {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.enable(gl.DEPTH_TEST);

        const fieldOfView = (45 * Math.PI) / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();

        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        const modelViewMatrix = mat4.create();
        mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]);
        mat4.rotate(modelViewMatrix, modelViewMatrix, cubeRotation, [0, 1, 1]);

        gl.uniformMatrix4fv(
          gl.getUniformLocation(program, "uProjectionMatrix"),
          false,
          projectionMatrix
        );
        gl.uniformMatrix4fv(
          gl.getUniformLocation(program, "uModelViewMatrix"),
          false,
          modelViewMatrix
        );

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(gl.getUniformLocation(program, "uSampler"), 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
      }

      let cubeRotation = 0.0;
      function render() {
        cubeRotation += 0.01;
        drawScene();
        requestAnimationFrame(render);
      }
      render();
    </script>
  </body>
</html>
